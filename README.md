# Using pytest

## Why?
- To run standalone test functions 
- Ability to use standard assert methods
- Unlike `unittest`, where you place tests into classes and handle class inheritance.
- Easier to define tests, unittest has over 10 different assertion methods 
- Pytest uses fixtures to automate test setup, teardown and common test scenarios for use in varying scopes
- Pytest is an open source project 

## Types of test
- Unit
- Integration 
- Linting 
- Smoke
- Functional Tests

## Objectives
- Pytest framework's core features: assertions, exceptions, fixtures, parametrisation
- Modularising common test utility functions with `conftest.py`
- Using TDD to add new functionality 

## Project 
- Adding destinations onto a map 

## Testing methods 
- Happy Path Testing
    - Organising positive cases into their own functions

- Sad Path Testing
    - Negative test cases to validate against
    - Halting the flow of the code execution or throw an exception
    - Log that an action could not be taken and continue code execution.

## Fixtures 
- Automate test setup and teardown 
- Comes in handy when tests use operations, e.g database or API contention 
- Can be scoped to execute at different times in our set suite

## Scoping Fixtures 
```python
@pytest.fixture(scope = "session")
    - Once per session 

@pytest.fixture(scope = "module")
    - Once per module 

@pytest.fixture(scope = "class")
    - Once per class of tests

@pytest.fixture(scope = "function")
    - Once per test
```
- When using fixtures we can scope them according to the following four scopes from highest (test session) to lowest scope (function level).
- Using scoping minimises the number of active fixtures during test runs.
- Scoping may help you avoid adding operations that slow down entire test suite.
- This happens because they're involved for the entire session rather than for each function.
- E.g. happy path test, transforms data to include population counts for each row of the country data, it appends a new column indicating if the row was updated or not.
    - In `clean_map.csv` file, Andorra in `line 2` is indicated in the population dictionary, it would gain an additional population field with the value from the dictionary
    - After it has been transformed it will also receive a field updated, which would evaluate to true since it has been updated.
    - The country Angola in `line 9` is not indicated in our population dictionary. 
    - Population field would be a none value.
    - In `sad_path` testing, we make sure that we cannot attempt to transform the data twice on lines 58 through 60 - we define the inability to transform data twice in the following script in our source code. 
   
## Using `conftest.py` for common functions
- Stores common utility test fixtures and extension code often referred to as 'hooks'
- Pytest collects the fixtures in the file so they are globally accessible within the testing directory 
- It must be placed under the `/tests` folder
-

---
## Understanding TDD
- Test-driven development is a software development process to illustrate what features the system will carry out. 
- The developer writes a test that will surely fail without code to implement its behaviour (aka red failure state)
- Developer must make sure it eventually passes by writing the minimum implementation code needed to get this test passing.
- TDD allows developers to focus on functionality in small pieces on the forefront. 
- Facilitates code reuse

---

## Managing data in Docker with volumes
- Volumes is a way to persist data generated by and used by Docker containers
- Decouples container from storage meaning storage is separated from the container and even if you delete or remove the container, the storage is still available
- Volumes used to share volume or data among different containers 
